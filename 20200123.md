#### 怎么理解Vue中的diff算法？

##### 我的回答：

​	因为在浏览器中，如果直接因为数据变动而修改DOM树，产生的渲染代价是非常大的。而虚拟DOM能够避免每次数据变化直接修改DOM树，再最终确定数据之后，再进行DOM树的渲染。即使是使用虚拟DOM，也存在小部分数据变化之后刷新整体DOM的情况，那是否有更优的解决方式呢？当然，就是Vue中使用到的diff算法。

​	diff算法的原理，每次有数据变化之后，就根据新旧两个虚拟的节点，进行比较。比较的逻辑为：逐层比较，深度优先。怎么理解此话呢？就是每次新旧两个节点进行比较时，做相应的判断：1.如果新旧两个节点不是相同的元素节点，则直接使用新的节点替换旧的节点；2.如果新旧节点的标签名相同，则比较他们对应的属性是否一致，如果新的节点比旧的节点有多余的属性，则添加在新节点上，如果旧的节点有多余的属性则删除；3.如果当前标签下还存在子元素，则进行子元素的比较，方法与当前判断一致，一直到最后一个元素。

​	diff的具体算法为： 1.首先是假设新旧节点的第一元素相同进行比较；2.如果不相同，再假设新旧节点一头一尾的第一元素相同进行比较；3.如果还是不相同，则进行循环进行新旧元素的比较。经过以上比较之后，得出最后的变动结果，进行DOM操作，这样使得浏览器的渲染消耗得到降低，性能也会得到相应得提示，是值得我们使用和学习的！





#### 杨老师解答：

​	源码分析1：必要性 lifecycle.js --- mountComponent()  组件中可能存在多个data中的key使用

​	源码分析2：执行方式 patch.js --- patchVnode()  diff发生的地方，整体策略：深度优先，同层比较

​	源码分析3：高效性 patch.js --- updateChildren()

​	ps: diff算法并非vue专用。

​	结论：

1. diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM做对比（即diff），将变化的地方更新在真实DOM上；另外，也需要diff高效的执行对比过程，从而降低时间复杂度O(n)。
2. vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方。
3. vue中diff执行的时刻是组件实例执行其更新函数时，它会对比上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。
4. diff过程整体遵循深度优先，同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组节点时算法的重点，首先假设头尾节点可能相同做4次对比尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结果再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效。